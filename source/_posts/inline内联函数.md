---
title: inline内联函数
date: 2022-12-05 16:09:32
tags:
---

### 内联函数介绍

内联函数就是使用了`inline`修饰的函数，例如

```c
inline int max(int a, int b)
{
    return a > b ? a : b;
}
```

### 内联函数的作用

C++调用函数时，会执行一系列操作：

* 将参数push到堆栈中
* 将返回地址push到堆栈中
* 准备返回值
* 将所有push到堆栈中的都pop出来

**非内联函数**调用操作毫无疑问**增加了延迟**，有**栈内存创建**和**释放**的开销。而内联函数的作用就是将**函数内容嵌入到函数调用**的地方，但仍然保持着**函数的独立性**，函数还有自己的独立空间，缺点是**增加空间消耗**（以**空间换时间**）。

直接调用函数：

```c
int main()
{
    int a = 4;
    int b = 3;
    int c = max(a,b);
}
```

使用 `inline` 修饰：

```java
int main()
{
    int a = 4;
    int b = 3;
    int c = a > b? a : b;
}
```

上面两种代码在执行过程中实际是一样的。

### 内联函数的使用

**隐式内联**：类的成员函数在,h文件中定义，默认为内联函数。

```c
class Demo {
public:
    int max(int a, int b) { return a > b ? a : b;}  //demo.h
};
```

**显式内联**：关键字`inline` 必须与函数定义体放在一起才能使函数成为内联，仅将`inline` 放在函数声明前面不起任何作用。

```c
class Demo {
public:
    int max(int a, int b);
};
inline int max(int a, int b){ return a > b ? a : b;}
```

**显式内联**时声明和定义尽量在同一个头文件中，否则必须在每个调用此函数的文件中实现一次，最好保证每个定义都是一样的，否则，将会引起未定义的行为，即是说，如果不是每个文件里的定义都一样，那么，编译器展开的是哪一个，那要看具体的编译器而定。所以,最好将内联函数**定义放在头文件**中. 

### 内联函数和宏定义的区别

宏是在代码处不加任何验证的简单替代，而内联函数是将代码直接插入调用处，而减少了普通函数调用时的资源消耗。宏不是函数，只是在编译前（编译预处理阶段）将程序中有关字符串替换成宏体。

`inline`函数是函数，但在编译中不单独产生代码，而是将有关代码嵌入到调用处。

内联函数要做**参数类型检查**，相比宏更加安全可靠，这是内联函数跟宏相比的优势。

```c
#define f(x) x*x
int main()
{
    double x=2;
    printf("%d", f(x));
}
```

```c
inline int f(int x) { return x*x;}
int main()
{
    double x = 2;
    printf("%d", f(x));
}
```

这两段代码都会产生warning，但第一个代码输出结果是错的，第二个输出结果的对的。这是为什么呢？因为宏定义不会做**类型检查**，f(x)的结果是一个double型的，而我们用`%d`来打印，结果肯定是不对的；而第二个代码中，x是double型，但函数`f`的参数类型是`int`型，因此会先进行类型转换后，再进行`x*x`的操作。

### 内联函数使用的注意事项

以下情况不用内联（会产生大量的内存开销）：

* 函数**内容太多**
* 函数包含**for、while、switch**语句，即函数中包含**递归**、**循环**等。

以下情况可以用内联（为了提高函数的执行速度）：

* 函数内容**10行以内**且**多次调用**。

### 小知识

函数**内容太多**，不管有没有加  `inline`， 编译器都不会将其编译成内联函数，因为内联`inline`只是**建议性**的关键字，编译器并不一定会听你的，他肯定比你更了解编译后是什么样的，而所谓的内联也不单单是指`inline`这个关键字了，他本质上是一种**编译器的优化方式**。



