---
title: 右值引用和移动构造
date: 2022-12-05 16:20:59
tags: C++
---

#### 左值和右值的区别

一个表达式是左值还是右值，取决于我们使用的是他的值还是他在内存中的位置（作为对象的身份）。一个表达式是左值还是右值，要根据实际咋语句中的含义来确定。

```c
int foo(42);
int bar;

//将foo的值赋给bar，保存在bar对应的内存中。
//foo在这里作为表达式是右值；bar在这里作为表达式是左值。
//但是foo作为对象，既可以充当左值又可以充当右值。
bar = foo;
```

C++对象本身可以是一个表达式，所以这里有一个重要的原则，即：

* 在大多数情况下，需要右值的地方可以用左值来替代
* 需要左值的地方，一定不能用右值来替代
* 左值存放在对象中，有持久的状态
* 右值要么是字面常量，要么是在表达式求值过程中创建的临时变量，没有持久的状态。

#### `std::move()`

将左值转换为右值，触发移动语义。

```c
//std::vector和std::string的实际例子
int main() {
    std::string str = "abcd";
    std::vector<std::string> vec;
     
    vec.push_back(str); // 传统方法
    vec.push_back(std::move(str)); // 调用移动语义的push_back方法，避免拷贝，str1会失去原有值，变成空字符串
    vec.emplace_back(std::move(str)); // emplace_back效果相同，str1会失去原有值
    vec.emplace_back("abcd"); // 当然可以直接接右值
}
 
std::vector方法定义
void push_back (const value_type& val);
void push_back (value_type&& val);
 
void emplace_back (Args&&... args);
```

#### 万能引用

```c
template<typename T>
void fun(T&& temp) {
    cout << temp << endl;
}

int main() {
    int num = 1;
    fun(num);
    fun(1);
    return 0;
}
```

发生类型推导的时候会表现为万能引用（如函数模版传参），其余情况为右值引用。

#### 引用折叠

```c
template<typename T>
void fun(T& temp) {
    cout << "左值" << endl;
}

template<typename T>
void fun(T&& temp) {
    cout << "右值" << endl;
}

template<typename T>
void func(T&& temp) {
    fun(temp);
}

int main() {
    int num = 1;
    func(num);
    func(1);
    return 0;
}
```

`func`()函数本身是一个万能引用，第一次接受了左值，调用`fun`()的时候传入的也是左值；第二次接受了右值，在`func`()函数中有临时变量`temp`，这是一个左值。

结论：**如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果才是右值引用**

#### 完美转发

C++11中通过`std::forward()`函数实现完美转发，实现了函数调用过程中变量类型的不变。

````c
template<typename T>
void func(T&& = temp) {
    fun(std::forward<T>(temp));
}
````

